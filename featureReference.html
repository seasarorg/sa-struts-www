<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<meta http-equiv="Content-Language" content="ja" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta name="keywords" content="sastruts, Seasar, The Seasar Project, The Seasar Foundation, OSS, Open Source Software, Java, Framework" />
<meta name="description" content="sastruts" />
<title>Super Agile Struts - Feature Reference</title>
<link rel="stylesheet" type="text/css" href="http://www.seasar.org/theme/main.css" media="screen,projection" />
<link rel="stylesheet" type="text/css" href="http://www.seasar.org/theme/print.css" media="print" />
</head>

<body>

<div id="wrapper">

<div id="header">

<div class="line"><span class="hide">spacer</span></div>

<div id="logo"><h2 id="h01" class="hide">The Seasar Foundation Project Site</h2><img src="http://www.seasar.org/images/seasar_logo_blue.gif" alt="The Seasar Project" width="390" height="180" /></div>

<div id="tool">

<h2><a href="http://search.seasar.org/">Site Search</a></h2>

<form id="search" name="search" action="http://search.seasar.org/">
<div>
	<input id="search_phrase" type="text" name="phrase" size="20" />
	<input type="hidden" name="perpage" value="30" />
	<input type="hidden" name="enc" value="UTF-8" />
	<input id="search_go" type="submit" value="Search" />
</div>
</form>

<h2>Seasar Banner</h2>

<p><a href="http://www.seasar.org/images/seasar_banner.gif"><img src="http://www.seasar.org/images/seasar_banner.gif" alt="Seasar Banner" title="Seasar Banner" width="146" height="33" /></a></p>

</div>

</div><!-- header -->


<div id="contents_left">

<h2>Menu</h2>

<ul>
    <li><a href="index.html">ホーム</a></li>
    <li><a href="setup.html">セットアップ</a></li>
    <li><a href="download.html">ダウンロード</a></li>
	<li><a href="tutorial.html">チュートリアル</a></li>
	<li><a href="featureReference.html">機能リファレンス</a>
		<ul>
			<li><a href="#Project">プロジェクト構成</a></li>
			<li><a href="#Architecture">アーキテクチャ</a></li>
			<li><a href="#Action">アクション</a></li>
			<li><a href="#ExecuteMethod">実行メソッド</a></li>
			<li><a href="#Validator">バリデータ</a></li>
			<li><a href="#ValidateMethod">検証メソッド</a></li>
			<li><a href="#DataAccess">データアクセス</a></li>
			<li><a href="#Transaction">トランザクション</a></li>
			<li><a href="#DataExchange">データ変換</a></li>
			<li><a href="#ActionForm">アクションフォーム</a></li>
			<li><a href="#JSP">JSP</a></li>
			<li><a href="#ResetMethod">リセットメソッド</a></li>
			<li><a href="#MessageResources">メッセージリソース</a></li>
		</ul>
	</li>
	<li><a href="annotationReference.html">アノテーションリファレンス</a></li>
</ul>

</div><!-- contents_left -->

<div id="contents_center">

<div id="article">

<div class="section">

<h2>機能リファレンス</h2>
<p>SAStrutsの機能リファレンスです。</p>

<h3><a name="Project">プロジェクト構成</a></h3>
<p>
SAStrutsでは、ルートパッケージの配下にactionなどのパッケージを作って、
そこに必要なファイルを格納します。
ルートパッケージ名は、任意の名前を指定することができます。
例えば、sa-struts-tutorialプロジェクトでは、ルートパッケージ名は、tutorialになっています。
</p>
<p>
ルートパッケージ名は、convention.diconで指定します。
sa-struts-tutorialプロジェクトでは、src/main/resourcesで次のように指定されています。
</p>
<h5>convention.dicon</h5>
<pre>
&lt;components&gt;
    &lt;component
        class="org.seasar.framework.convention.impl.NamingConventionImpl"&gt;
        <b>&lt;initMethod name="addRootPackageName"&gt;
            &lt;arg&gt;"tutorial"&lt;/arg&gt;
        &lt;/initMethod&gt;</b>
    &lt;/component&gt;
    &lt;component
        class="org.seasar.framework.convention.impl.PersistenceConventionImpl"/&gt;
&lt;/components>
</pre>
<p>
<a href="#Action">アクション</a>は、ルートパッケージ.actionに格納します。
例えば、http://ホスト名/プロジェクト名/xxx/のURLに対応するアクションクラスは、
ルートパッケージ.action.XxxActionという名前にします。
</p>
<p>
<a href="#ActionForm">アクションフォーム</a>は、ルートパッケージ.dtoに格納します。
例えば、XxxActionで利用するアクションフォームは、XxxDtoという名前にします。
通常は、<a href="#ActionForm">アクションフォーム</a>を定義する必要はありません。
<a href="#Action">アクション</a>で状態も一緒に管理したほうが、
関連する定義が近くにあるので、わかりやすいためです。
</p>
<p>
<a href="http://s2container.seasar.org/2.4/ja/s2jdbc_entity.html">エンティティ</a>は、
ルートパッケージ.entityに格納します。
エンティティとは、データベースに永続化されるデータです。
エンティティの名前は任意の名前にすることができますが、
通常は、テーブルの名前にあわせます。
</p>
<p>
サービスは、ルートパッケージ.serviceに格納します。クラス名の最後は、Serviceで終わるようにします。
複数の<a href="#Action">アクション</a>から共通に使われるような機能は、
サービスクラスで実装すると良いでしょう。
サービスは、インターフェースと実装に分ける必要はなく、実装のみで良いでしょう。
テストのときにモックが必要なら、実装クラスを継承したモッククラスでメソッドを
モック用に上書きすればよいからです。
</p>
<p>
ユーティリティは、ルートパッケージ.utilに格納します。
クラス名は自由につけてかまいません。
ユーティリティクラスは、通常staticメソッドで構成されています。
</p>
<p>
<a href="#JSP">JSP</a>は、アクションに対応するディレクトリに格納します。
例えば、XxxActionで使うJSPは、/xxx/に格納すると良いでしょう。
</p>

<h3><a name="Architecture">アプリケーションアーキテクチャ</a></h3>
<p>
SAStrutsは、MVC(Model View Controller)のアーキテクチャに基づいていて、
Modelは<a href="http://s2container.seasar.org/2.4/ja/s2jdbc_entity.html">エンティティ</a>、
Viewは<a href="#JSP">JSP</a>、Controllerは<a href="#Action">アクション</a>になります。
</p>
<p>
<a href="#Action">アクション</a>は、複数の<a href="#ExecuteMethod">実行メソッド</a>
を持つことができ、通常は、1ユースケースを1アクションにマッピングします。
複数の画面で構成される意味のある単位をユースケースだと、とらえればよいでしょう。
</p>
<p>
ビジネスロジックは、<a href="http://s2container.seasar.org/2.4/ja/s2jdbc_entity.html">エンティティ</a>に
定義します。ビジネスロジックと間違えやすいのが、データアクセスのロジックと、
エンティティの関連をたどるような複数種類のエンティティにまたがるようなロジックです。
</p>
<p>
データアクセスのロジックは、<a href="#Action">アクション</a>に記述します。
データアクセスのロジックをDaoクラスに抽出する方法もありますが、
<a href="http://s2container.seasar.org/2.4/ja/s2jdbc.html">S2JDBC</a>を使うと、
ほとんどのデータアクセスロジックは、一度JdbcManagerを呼び出して終わりというような
スカスカなメソッドになってしまいます。
データアクセスのロジックは、<a href="#Action">アクション</a>に直接記述したほうが、
わかりやすいでしょう。
</p>
<p>
エンティティの関連をたどるような複数種類のエンティティにまたがるようなロジックは、
<a href="#Action">アクション</a>に記述します。
複数種類のエンティティにまたがるようなロジックは、
どのエンティティ所属するのかあいまいなので、
制御ロジックととらえ、<a href="#Action">アクション</a>に記述するほうがわかりやすいでしょう。
</p>

<h3><a name="Action">アクション</a></h3>
<p>
リクエストに応じて起動されるクラスをアクションといいます。
Strutsでは、URLとアクションの関係をstruts-config.xmlに記述しますが、
SAStrutsでは、次のルールに従って自動的に決まるので、
設定ファイルを書く必要がありません。
</p>
<p>
http://localhost:8080/sa-struts-tutorial/login/にアクセスしたとします。
sa-struts-tutorialはWebアプリケーション名です。
SAStrutsは、次のような手順でURLをActionクラスに変換します。
</p>
<ul>
<li>
Webアプリケーション名の後ろのパス(/login/)の最後のスラッシュをActionに変換(/loginAction)します。
スラッシュがない場合は後ろにActionを付け加えます。
</li>
<li>
最後のスラッシュの直後を大文字(/LoginAction)にします。
</li>
<li>
スラッシュをドットに変換(.LoginAction)します。
</li>
<li>
ルートパッケージ名.actionを先頭につけます(ルートパッケージ名.action.LoginAction)。
ルートパッケージ名の詳細は、<a href="#Project">こちら</a>を参照してください。
</li>
<li>
最終的に、/login/に対応するアクションクラスはtutorial.action.LoginActionになります。
</li>
</ul>
<p>
大規模なアプリケーションでは、パスを分割することもできます。
例えば、/aaa/bbb/のパスに対応するアクションクラスは、
ルートパッケージ.action.aaa.BbbActionになります。
</p>
<p>
アクションはPOJO(普通のJavaのクラス)にします。StrutsのようにActionを継承する必要はありません。
HttpServletRequestやHttpServletResponseなどのServlet API関連のオブジェクトは、
次のようにプロパティを定義しておけば、Seasar2が自動的に設定します。
</p>
<pre>
public class MyAction {
    public HttpServletRequest request;
    public HttpServletResponse response;
    public HttpSession session;
    public ServletContext application;
    ...
}
</pre>
<p>
Seasar2は、publicフィールドをプロパティとみなすので、
setter,getterメソッドをいちいち定義する必要はありません。
setter,getterメソッドを定義してもかまいませんが、
何かと面倒なので、publicフィールドにすることをお勧めします。
</p>
<p>
Strutsでは、リクエストのパラメータの内容は、アクションフォームで受け取りますが、
SAStrutsでは、アクションにリクエストのパラメータ名と同じ名前のプロパティを
定義しておけば、アクションで受け取ることができます。
入力値を受け取るためのプロパティは、バリデーションエラーになっても値を格納できるように
プロパティの型をStringあるいはbooleanで定義してください。
アクションフォームをアクションとは別に定義することもできます。
詳しくは<a href="#ActionForm">アクションフォームの説明</a>を参照してください。
</p>
<p>
アクションのプロパティの値は、リクエストの属性にプロパティと同じ名前でセットされています。
そのため、ELやJSTLで次のように参照することができます。
エスケープが必要なケースは、f:h()を使ってください。
</p>
<pre>
${プロパティ名}
${f:h(プロパティ名)}
</pre>
<p>
アクションは、リクエストスコープで管理されています。
セッションスコープにすることはできません。
セッションスコープを使いたい場合は、<a href="#ActionForm">アクションフォーム</a>を
セッションスコープで管理してください。
</p>
<p>
ログインしたユーザに関する情報など、
<a href="#ActionForm">アクションフォーム</a>以外をセッションで管理したい場合、
ルートパッケージ.dtoにXxxDto作成し、@Componentでセッションで管理されるように定義します。
</p>
<pre>
@Component(instance = InstanceType.SESSION)
public class UserDto implements Serializable {

    private static final long serialVersionUID = 1L;
    
    public String userName;
    ...
}
</pre>
<p>
作成したUserDtoをアクションで利用するには、次のようにプロパティを定義しておけば、
Seasar2が自動的に設定します。フィールド名は、クラス名の先頭を小文字にしたものにします。
</p>
<pre>
public UserDto userDto;
</pre>
<p>
複数のアクションから共通に使われるようなロジックをサービスで定義する場合、
ルートパッケージ.serviceにXxxServiceを作成します。
</p>
<pre>
public class XxxService {
    ...
}
</pre>
<p>
作成したXxxServiceをアクションで利用するには、次のようにプロパティを定義しておけば、
Seasar2が自動的に設定します。フィールド名は、クラス名の先頭を小文字にしたものにします。
</p>
<pre>
public XxxService xxxService;
</pre>
<p>
リクエストに対する処理を記述したい場合は、
<a href="#ExecuteMethod">実行メソッド</a>を定義します。
</p>
<p>
入力値の検証は、<a href="#Validator">検証用のアノテーション</a>を定義します。
</p>
<p>
入力値に対する検証をロジックで記述したい場合は、
<a href="#ValidateMethod">検証メソッド</a>を定義します。
</p>

<h3><a name="ExecuteMethod">実行メソッド</a></h3>
<p>
リクエストに対する処理は、実行メソッドに記述します。
実行メソッドは、<a href="annotationReference.html#Execute">@Execute</a>がつけられている任意の名前のメソッドで、
戻り値はString、引数は無しにする必要があります。
</p>
<pre>
@Execute
public String execute() {
    ...
    return ...;
}
</pre>
<p>
実行メソッドの戻り値は、遷移先のパスです。
パスが/ではじまっていない場合、アクションのパスからみた相対パスとみなされます。
</p>
<p>
例えば、http://localhost:8080/sa-struts-tutorial/login/のアクションで
戻り値をlogin.jspとした場合<br />
http://localhost:8080/sa-struts-tutorial/login/login.jspに遷移します。
</p>
<p>
パスが/ではじまっている場合、Webアプリケーションのルートからの相対パスと
みなされます。例えば、戻り値を/selectとした場合、
http://localhost:8080/sa-struts-tutorial/select/に遷移します。
</p>
<p>
デフォルトではフォワードで遷移しますが、リダイレクトで遷移したい場合は、
パスの<b>最後</b>に<b>redirect=true</b>を追加します。
=の前後に余分な空白は含めないでください。
redirect=trueの部分は、実際に実行されるときには、消去されます。
</p>
<pre>
...
return "xxx.jsp?redirect=true";
</pre>
<pre>
...
return "xxx.jsp?key=value&amp;redirect=true";
</pre>
<p>
別のサイトに遷移したい場合は、パスをhttpやhttpsではじめ、
リダイレクトするように指定します。
</p>
<pre>
...
return "https://ホスト名/アプリケーション名/パス?redirect=true";
</pre>
<p>
1つのアクションに複数の実行メソッドを定義することができます。
どの実行メソッドが選択されるのかは、URLで指定するか、
リクエストのパラメータのキーにメソッド名が含まれている(値が1文字以上あること)かどうかで決まります。
</p>
<p>
次の例では、LoginAction#index()が呼び出されます。
</p>
<pre>
http://localhost:8080/sa-struts-tutorial/login/index/
</pre>
<p>
メソッドが定義されていない場合、index()が呼び出されるので、
上記の呼び出しは、下記の呼び出しと一緒です。
</p>
<pre>
http://localhost:8080/sa-struts-tutorial/login/
</pre>
<p>
@ExecuteでURLのパターン(urlPattern)を指定することで、
URLの一部をパラメータの値として受け取ることができます。
例えば、EmployeeAction#edit()が次のように定義されているとします。
</p>
<pre>
@Execute(urlPattern = "edit/{id}")
public String edit() {
    ...
}
</pre>
<p>
urlPatternの{}で囲まれている部分をパラメータとして受け取ることができます。
/employee/list.jspに次のようなアンカータグが定義されている場合、
アンカータグをクリックするとidプロパティが1に設定されて、
EmployeeAction#edit()が呼び出されます。
</p>
<pre>
&lt;a href="edit/1"&gt;編集画面へ&lt;/a&gt;
</pre>
<p>
フォームをサブミットする場合は、ボタン系のname属性に実行メソッド名を指定します。
次の例では、アクションクラスのsubmit()が呼び出されます。
</p>
<pre>
&lt;input type="submit" name="submit" value="サブミット"/&gt;
</pre>
<p>
実行メソッドを呼び出す前に、<a href="http://commons.apache.org/validator/">commons validator</a>を使った
検証を行なうには、@Executeのvalidator属性をtrueにします。デフォルトはtrueです。
</p>
<p>
validator=trueの場合は、検証結果がNGのときの遷移先のパスをinput属性で指定します。
パスの書き方は、実行メソッドの戻り値の場合と一緒です。
バリデータの詳細は、<a href="#Validator">こちら</a>を参照してください。
</p>
<pre>
@Execute(validator = true, input = "edit.jsp")
</pre>
<p>
実行メソッドを呼び出す前に、アクションクラスのメソッドで検証を行なうには、
@Executeのvalidate属性で検証用のメソッド名を指定します。
</p>
<p>
validate属性を指定した場合は、検証結果がNGのときの遷移先のパスをinput属性で指定します。
パスの書き方は、実行メソッドの戻り値の場合と一緒です。
validator属性とvalidate属性を両方指定した場合には、
バリデータのほうが先に実行されます。
検証メソッドの詳細は、<a href="#ValidateMethod">こちら</a>を参照してください。
</p>
<pre>
@Execute(validate = "validate", input = "login.jsp")
</pre>

<h3><a name="Validator">バリデータ</a></h3>
<p>
<a href="http://commons.apache.org/validator/">commons validator</a>を使った検証を行なうには、
アクションやアクションフォームのフィールドに検証用のアノテーションを指定します。
検証用のアノテーションの詳細は、<a href="annotationReference.html#Validation">こちら</a>を参照してください。
</p>
<pre>
@Required
public String userName;
</pre>
<p>
検証結果がNGの場合に出力されるメッセージは、<a href="#MessageResources">メッセージリソース</a>に
記述します。検証用のアノテーションとメッセージのキーは次のようになっています。
</p>
<table>
<tr><th>アノテーション</th><th>メッセージのキー</th></tr>
<tr><td>Required</td><td>errors.required</td></tr>
<tr><td>Validwhen</td><td>開発者が指定</td></tr>
<tr><td>Minlength</td><td>errors.minlength</td></tr>
<tr><td>Maxlength</td><td>errors.maxlength</td></tr>
<tr><td>Minbytelength</td><td>errors.minbytelength</td></tr>
<tr><td>Maxbytelength</td><td>errors.maxbytelength</td></tr>
<tr><td>Mask</td><td>errors.invalid</td></tr>
<tr><td>IntRange</td><td>errors.range</td></tr>
<tr><td>LongRange</td><td>errors.range</td></tr>
<tr><td>FloatRange</td><td>errors.range</td></tr>
<tr><td>DoubleRange</td><td>errors.range</td></tr>
<tr><td>ByteType</td><td>errors.byte</td></tr>
<tr><td>ShortType</td><td>errors.short</td></tr>
<tr><td>IntegerType</td><td>errors.integer</td></tr>
<tr><td>LongType</td><td>errors.long</td></tr>
<tr><td>FloatType</td><td>errors.float</td></tr>
<tr><td>DoubleType</td><td>errors.double</td></tr>
<tr><td>DateType</td><td>errors.date</td></tr>
<tr><td>CreditCardType</td><td>errors.creditcard</td></tr>
<tr><td>EmailType</td><td>errors.email</td></tr>
<tr><td>UrlType</td><td>errors.url</td></tr>
</table>
<p>
メッセージをカスタマイズしたい場合は、キーに対応する値を書き換えてください。
</p>
<p>
特定のプロパティのみ、メッセージをカスタマイズしたい場合は、
<a href="#MessageResources">メッセージリソース</a>に、
メッセージを追加し、検証用のアノテーションのmsg属性で指定します。
</p>
<pre>
errors.required2={0}は必須だぜ。
</pre>
<pre>
@Required(msg = @Msg(key = "errors.required2"))
</pre>
<p>
メッセージには、{位置}で引数を渡すことができます。
位置は0からはじまります。
検証用のアノテーションで、引数を指定するには、arg0, arg1, ..., args属性で指定します。
</p>
<pre>
@Required(arg0 = @Arg(key = "ほげ", resource = false))
</pre>
<pre>
@Validwhen(test = "((validwhen1Text == null) or (*this* != null))",
    msg = @Msg(key = "errors.required.other"),
    args = @Arg(key = "validwhen1Text", resource = false, position = 1))
</pre>
<p>
最初の引数は、プロパティ名が自動的に設定されます。
プロパティの表示をカスタマイズしたい場合は、
<a href="#MessageResources">メッセージリソース</a>に<br />
<b>labels.プロパティ名=...</b>のエントリを追加してください。
</p>
<pre>
labels.userName=ユーザ名
</pre>
<p>
target属性を指定することで、特定のメソッドの場合だけ、検証を行なうようにすることもできます。
複数のメソッドを指定する場合は、カンマで区切ります。
target属性が指定されていない場合、@Executeでvalidator=trueのすべての実行メソッドが対象になります。
次の例では、secondプロパティは、goThirdメソッドが呼び出されるときだけ、
入力必須になります。
</p>
<pre>
@Required(target = "goThird")
public String second;
</pre>
<p>
JSPでエラーメッセージを出力するには、次のようにhtml:errorsタグを使います。
</p>
<pre>
&lt;%@taglib prefix="html" uri="http://struts.apache.org/tags-html"%&gt; 
...
&lt;html:errors /&gt;
</pre>
<p>
独自の検証用アノテーションを追加したい場合は、
org.seasar.struts.validator.S2FieldChecksを参考にして、
検証ロジックを実装し、そのメソッドをvalidator-rules.xmlで指定します。
</p>
<p>
そして、validator-rules.xmlで指定したvalidatorの名前を
<a href="annotationReference.html#Validator">Validatorアノテーション</a>で
指定してください。
</p>

<h3><a name="ValidateMethod">検証メソッド</a></h3>
<p>
<a href="#Validator">バリデータ</a>では検証できないような複雑なものは、
<a href="#Action">アクション</a>の検証メソッドを使います。
</p>
<p>
検証メソッドには、任意の名前をつけることができ、戻り値はActionMessages、
引数は無しにする必要があります。
戻り値のActionMessagesが空でない場合、検証結果はNGだとみなされます。
</p>
<pre>
public ActionMessages validate() {
    ActionMessages errors = new ActionMessages();
    ...
    return errors;
}
</pre>
<p>
実行メソッドで、どの検証メソッドを使うのかは、validate属性で指定します。
validate属性を指定した場合は、
input属性に検証結果がNGのときの遷移先も指定する必要があります。
</p>
<pre>
@Execute(validate = "validate", input = "login.jsp")
</pre>
<p>
ログインをするときの実行メソッドと検証メソッドは次のようになります。
</p>
<pre>
@Execute(validate = "validate", input = "login.jsp")
public String login() {
    return "welcome.jsp";
}

public ActionMessages validate() {
    ActionMessages errors = new ActionMessages();
    if (!userName.equals(password)) {
        errors.add(ActionMessages.GLOBAL_MESSAGE,
            new ActionMessage("errors.invalid.login"));
    }
    return errors;
}
</pre>
<p>
<a href="#Action">アクション</a>以外で、検証を行ないたい場合は、
検証結果がNGの場合、ActionMessagesExceptionをスローします。
</p>
<pre>
public void validateLogin(String userName, String password) {
    if (!userName.equals(password)) {
        throw new ActionMessagesException("errors.invalid.login");
    }
}
</pre>
<p>
ActionMessagesExceptionの処理は、app.diconに<br />
org.seasar.struts.interceptor.ActionMessagesThrowsInterceptorを登録し、
customizer.diconで登録したインターセプタを使うように記述しておけば、
個別のアクションでは何もする必要はありません。
カスタマイザの詳細は、<a href="http://s2container.seasar.org/2.4/ja/DIContainer.html#Customizer">こちら</a>を参照してください。
</p>
<h5>app.dicon</h5>
<pre>
&lt;component name="actionMessagesThrowsInterceptor"
    class="org.seasar.struts.interceptor.ActionMessagesThrowsInterceptor"/&gt;
</pre>
<h5>customizer.dicon</h5>
<pre>
&lt;component name="actionCustomizer"
    class="org.seasar.framework.container.customizer.CustomizerChain"&gt;
    ...
    &lt;initMethod name="addAspectCustomizer"&gt;
        &lt;arg&gt;"actionMessagesThrowsInterceptor"&lt;/arg&gt;
    &lt;/initMethod&gt;
    ...
&lt;/component&gt;
</pre>

<h3><a name="DataAccess">データアクセス</a></h3>
<p>
</p>

<h3><a name="Transaction">トランザクション</a></h3>
<p>
</p>

<h3><a name="DataExchange">データ変換</a></h3>
<p>
</p>

<h3><a name="ActionForm">アクションフォーム</a></h3>
<p>
SAStrutsでは、アクションフォームもPOJOで記述することができます。
リクエストのパラメータ名と同じ名前のプロパティをアクションフォームに定義します。
入力値を受け取るためのプロパティは、バリデーションエラーになっても値を格納できるように
プロパティの型をStringあるいはbooleanで定義してください。
</p>
<p>
アクションフォームクラスは、ルートパッケージ.dtoにおき、クラス名の最後は、Dtoで終わるようにします。
</p>
<p>
SAStrutsのアクションフォームは、デフォルトだとリクエストスコープで管理されますが、
次のようにアノテーションを指定することで、
セッションスコープで管理することもできます。
セッションスコープで管理するコンポーネントは、
java.io.Serializableをimplementsする必要があります。
@Componentの詳細は、<a href="http://s2container.seasar.org/2.4/ja/DIContainer.html#ComponentAnnotation">こちら</a>を参照してください。
</p>
<pre>
@Component(instance = InstanceType.SESSION)
public class FormDto implements Serializable {

    private static final long serialVersionUID = 1L;
    ...
}
</pre>
<p>
アクションフォームを利用するには、アクションのプロパティに@ActionFormを指定します。
@ActionFormを複数指定しても意味がないので、
複数指定しないようにしてください。
アクションフォームのプロパティ名は、クラス名の先頭を小文字にしたものにします。
後は、Seasar2が自動的に設定してくれます。
詳しくは、<a href="http://s2container.seasar.org/2.4/ja/DIContainer.html#AutoBindingMode">自動バインディング</a>
を参照してください。
</p>
<pre>
public class FormAction {

    @ActionForm
    public FormDto formDto;
    ...
}
</pre>
<p>
検証メソッドはアクションフォームではなく、<a href="#Action">アクション</a>に定義します。
複数のアクションでアクションフォームを共用した場合、
検証の内容は、アクションごとに異なることがほとんどだからです。
</p>
<p>
resetメソッドは<a href="#ResetMethod">こちら</a>を参照してください。
</p>

<h3><a name="JSP">JSP</a></h3>
<p>
JSPはどのように配置してもかまいませんが、
/xxx/というパスに対応するXxxAction用のJSPは、/xxx/に格納すると良いでしょう。
</p>


<h3><a name="ResetMethod">リセットメソッド</a></h3>
<p>
チェックボックス(&lt;input type="checkbox" .../&gt;)や
複数選択リスト(&lt;select multiple="multiple" ...&gt;&lt;/select&gt;)
では、選択された値のみをブラウザはリクエストで送信します。
何も選択しなかった場合は、ブラウザは何も送信してくれません。
そのため、アクションフォームをセッションで管理している場合、
チェックボックスや複数選択リストで選択状態をすべて解除しても
何もリクエストで送信されないため、元の状態のまま残ってしまいます。
</p>
<p>
この問題に対応するために用意されているのが、
アクションフォームのreset()です。
reset()は、リクエストパラメータをアクションフォームにセットする直前に呼び出されるため、
reset()で、チェックボックスや複数選択リストのプロパティを選択されていない状態に更新することで、
リクエストで何も送られてこなかった場合でも、選択状態を解除することができます。
</p>
<pre>
@Component(instance = InstanceType.SESSION)
public class XxxDto implements Serializable {

    private static final long serialVersionUID = 1L;
    
    public boolean foo;
    
    public String[] bar;
    ...
    public void reset() {
        foo = false;
        bar = new String[0];
    }
}
</pre>

<h3><a name="MessageResources">メッセージリソース</a></h3>
<p>
アプリケーションで使うメッセージは、xxx.propertiesに記述します。
xxx.propertiesはクラスパスの通っているディレクトリに配置します。
多言語対応する場合は、ロケールに応じて、xxx_ja.propertiesなどを用意してください。
xxxの部分は、struts-config.xmlのmessage-resourcesタグのparameter属性に設定します。
</p>
<pre>
&lt;message-resources parameter="xxx"
    factory="org.seasar.struts.util.S2PropertyMessageResourcesFactory"/&gt;
</pre>
<p>
sa-struts-tutorialプロジェクトでは、
src/main/resourcesにapplication.propertiesが配置されています。
</p>
<p>
xxx.propertiesを日本語で入力するためには、
<a href="http://propedit.sourceforge.jp/">プロパティエディタ</a>を使うのが、
お勧めです。
Eclipseをお使いの方は、更新マネージャを使って下記のURLからインストールして下さい。
</p>
<pre>
http://propedit.sourceforge.jp/eclipse/updates/
</pre>

</div><!-- section -->

</div><!-- article -->

</div><!-- contents_center -->

<div id="footer">
<address>&copy; Copyright The Seasar Foundation and the others 2006, all rights reserved.</address>
<div class="line"><span class="hide">spacer</span></div>
</div><!-- footer -->

</div><!-- wrapper -->

</body>
</html>

